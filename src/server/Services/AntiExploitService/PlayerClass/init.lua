local FlagClass = require(script.Parent.FlagClass)
local ExploitChecks = require(script.ExploitChecks)

local Utils = require(script.Parent.Utils)
local ThreadUtil = Utils.ThreadUtil
local Maid = Utils.Maid

local PlayerClass = {}
PlayerClass.__index = PlayerClass

PlayerClass.count = 0;

local function dist(pos1,pos2)
	return (pos1-pos2).Magnitude
end

function PlayerClass:AddFlag(Reason)
	local flag = FlagClass.new(Reason)
	self.Flags[flag.Id] = flag
	self.Flags.NumberOfFlags += 1
end

function PlayerClass:RemoveFlag(id)
	self.Flags[id] = nil
	self.Flags.NumberOfFlags -= 1
end

function PlayerClass:ResetStats(resetMessage,shouldWarn)
	resetMessage = resetMessage or "No Message Given"
	local info = self.Info
	if info.LastReset and info.LastChecked then
		if (info.LastReset>info.LastChecked) then
			return
		end 
	end
	local whiteList = {
		["Name"] = true,
		["Player"] = true,
	}
	for name,val in pairs(info)do
		local valType = typeof(val)
		if not whiteList[name] then
			if valType == "table" then
				info[name] = {}
			else
				info[name] = nil
			end
		end
	end
	info.LastReset = tick()
	if not shouldWarn then
		warn(info.Name.."'s Data Wiped Because: "..resetMessage)
	end
end

function PlayerClass:UpdateStats()
	local clientInfo = self.Info

	local Character = clientInfo.Player.Character
	
	if self.CanUpdate and Character then
		local rootPart = Character:FindFirstChild("HumanoidRootPart")
		local head =  Character:FindFirstChild("Head")
		clientInfo.LastChecked = tick()
		clientInfo.RootPart = rootPart
		clientInfo.Head = head
		clientInfo.LastPosition = rootPart.Position
	end
end

function StopPlayer(Character)
	ThreadUtil.Spawn(function()
		for _, Part in pairs(Character:GetDescendants()) do
			if Part:IsA("BasePart")then
				if Part:CanSetNetworkOwnership() then
					Part:SetNetworkOwner(nil)
				end
			end
		end
	end)
	ThreadUtil.Delay(5,function()
		for _, Part in pairs(Character:GetDescendants()) do
			if Part:IsA("BasePart")then
				if Part:CanSetNetworkOwnership() then
					Part:SetNetworkOwner(game.Players:GetPlayerFromCharacter(Character))
				end
			end
		end
	end)
end


function PlayerClass:Update()
	local clientInfo = self.Info
	local client = clientInfo.Player
	local character = client.Character
	if character and self.CanUpdate then
		local humanoid = character:FindFirstChildWhichIsA("Humanoid")
		local rootPart = character:FindFirstChild("HumanoidRootPart")
		local playerHead =  character:FindFirstChild("Head")
		if rootPart and playerHead then
			self.count = 0

			if clientInfo.LastPosition then
				if dist(clientInfo.LastPosition,rootPart.Position) < 0.3 or humanoid.SeatPart then
					return
				end
			else 
				self:UpdateStats()
			end
			clientInfo.RootPart = rootPart --Setting new value
			clientInfo.Head = playerHead
			-- if playerHasException then
			-- 	return
			-- else.. run these checks below 
			
			for name,exploit in pairs(ExploitChecks)do --Checking for any exploits	
				local Passed,ReturnMessage = exploit:Check(self)
				if not Passed then
					exploit:Punish(self)
					self:AddFlag(ReturnMessage)
					StopPlayer(character)
					warn(ReturnMessage)
					break
				end
			end
			self:UpdateStats()
		elseif not rootPart or not playerHead then
			self.count += 1
			if self.count >= 100 then
				self.count = 0
				if not rootPart or not playerHead then
					self.Info.Player:LoadCharacter()
					warn(self.Info.Player.Name.." doesn't have an important body part")
				end
			end
		end
	end
end

function PlayerClass.new(Player)
	local self =  setmetatable({		
		["Flags"] = {["NumberOfFlags"] = 0,},				
		["TimeStarted"] = tick(),
		["CanUpdate"] = true,
		["ExcemptSitting"] = true,
		["Info"] = {
			["Name"] = Player.Name,
			["Player"] = Player,
						
			["Humanoid"] = nil, --This is so we know what you can usually index 
			["Head"] = nil,
			["RootPart"] = nil,
			["LastPosition"] = nil, 
			["LastChecked"] = nil,
			["LastUpdated"] = nil,
		},
		["_maid"] = Maid.new(),		
		["_state"] = true,	
		
	},PlayerClass)
	self._maid["CharacterChanged"] = Player.CharacterAdded:Connect(function(Char)
		local Root = Char:WaitForChild("HumanoidRootPart")
		if self._maid["CFrameChanged"] then
			self._maid["CFrameChanged"] = nil
		end
		self._maid["CFrameChanged"] = Root:GetPropertyChangedSignal("CFrame"):Connect(function()
			self.CanUpdate = false
			self:ResetStats(Player.Name.." CFrame changed because of the Server",true)
			ThreadUtil.Delay(3,
				function()
					self.CanUpdate = true
				end
			)
		end)
		if Root then
			self.CanUpdate = true
			self:UpdateStats()					
		end		
	end)
	self._maid["CharacterRemoved"] = Player.CharacterRemoving:Connect(function(Char)
		self.CanUpdate = false
	end)		
	return self

end

function PlayerClass:Destroy()
	self._maid:DoCleaning()
end

return PlayerClass
